# プロジェクト計画: AI推論プロキシサーバー

## フェーズ1: 要求分析

**目的:**
【解説】このフェーズでは、フェーズ0で定義したMVP（Minimum Viable Product）のスコープに基づき、実装すべき機能をより具体的に定義します。どのような機能が必要か（機能要求）、性能や使いやすさなどの品質（非機能要求）、そしてユーザーがどのようにシステムを使うか（ユースケース）を明確にすることで、設計・開発フェーズでの手戻りを減らし、スコープを確定させます。

**想定期間:**
【解説】機能要求の洗い出し、非機能要求の定義、ユースケースの作成にかかる期間を見積もります。MVPのスコープが明確であれば、0.5週〜1週間程度が目安です。
【記入例】`{{0.5週}}`

---

### 1. 機能要求の洗い出しと詳細化 (MVPスコープ)

**【解説】**
フェーズ0で定義した「MVPの主要機能」を、より具体的な仕様レベルに落とし込みます。各機能について、何を入力とし、どのような処理を行い、何を出力するのかを明確にします。GitHub Issueとして個別に起票する際のベースとなります。

* **FR-01: 設定ファイル読み込み**
  * 【解説】サーバー起動時にYAML形式の設定ファイルを読み込む機能に関する要求です。
  * **要求:**
    * 起動時に指定されたパス（例: `config.yaml`）から設定ファイルを読み込むこと。パスはコマンドライン引数や環境変数で指定可能にすることを検討する `{{(検討事項)}}`。
    * YAMLファイルの構文が不正な場合は、エラーメッセージを出力して起動を中止すること `{{(エラー処理)}}`。
    * `server` セクション（`host`, `port`）を解釈し、FastAPIサーバーの設定に反映すること。デフォルト値も考慮する `{{(デフォルト値)}}`。
    * `services` セクションを解釈し、各サービス定義（サービスID、タイプ、ポート、リソース要件、ボリューム、引数など）を内部データ構造として保持すること。
    * MVPでは `services.<service_id>.type` は `llama-cpp-server` のような特定の値のみを許容する `{{(MVP制約)}}`。
    * 設定値のバリデーションを行うこと（例: ポート番号の範囲、必須項目の存在チェック）。バリデーションエラー時は具体的なエラーメッセージを出力して起動を中止する `{{(バリデーション)}}`。(Pydanticモデルで実現)
  * **入力:** `{{YAML設定ファイル(config.yaml)}}`
  * **出力:** `{{内部的な設定データ構造、FastAPIサーバー設定}}`
  * **備考:** `{{Pydantic または Pydantic-Settings を利用した型安全な読み込みとバリデーションを想定}}`

* **FR-02: 基本的なプロキシ機能**
  * 【解説】受け付けたリクエストを、対応するバックエンドコンテナに転送する機能に関する要求です。
  * **要求:**
    * `/service/{service_id}/{path:path}` の形式のパスでリクエストを受け付けること。
    * リクエストパスから `service_id` を抽出し、対応するサービス設定（特に転送先ポート）を取得すること。
    * 対応するサービスが存在しない場合は、`{{404 Not Found}}` エラーを返すこと。
    * 対応するコンテナが **実行中でない場合** は、`{{503 Service Unavailable}}` エラー（または適切なエラー）を返すこと `{{(MVP挙動、自動起動は含めない)}}`。
    * 元のリクエストのHTTPメソッド（GET, POST, PUT, DELETEなど）、ヘッダー、クエリパラメータ、ボディを維持して、バックエンドコンテナ（`http://localhost:<コンテナポート>/{path}`）に転送すること。
    * バックエンドコンテナからのレスポンス（ステータスコード、ヘッダー、ボディ）をそのままクライアントに返すこと。
    * バックエンドコンテナへの接続に失敗した場合（例: コンテナが応答しない）は、`{{502 Bad Gateway}}` エラーを返すこと。
  * **入力:** `{{クライアントからのHTTPリクエスト (メソッド, パス, ヘッダー, ボディ)}}`
  * **出力:** `{{バックエンドコンテナからのHTTPレスポンス または エラーレスポンス}}`
  * **備考:** `{{FastAPIの Reverse Proxy ライブラリ (例: httpx-reverse-proxy) や httpx を直接利用することを検討}}`

* **FR-03: 手動コンテナ管理API (起動)**
  * 【解説】指定されたサービスのコンテナを手動で起動するAPIに関する要求です。
  * **要求:**
    * `POST /api/v1/service/{service_id}/start` エンドポイントを実装すること。
    * リクエストパスから `service_id` を抽出し、対応するサービス設定を取得すること。存在しない場合は `{{404 Not Found}}` を返す。
    * 指定されたサービスIDのコンテナが既に実行中の場合は、`{{409 Conflict}}` エラー（または成功を示すメッセージ）を返す `{{(冪等性考慮)}}`。
    * サービス設定に基づき、Docker SDK for Python を使用してコンテナを起動すること。設定ファイルで指定されたイメージ、ポートマッピング、ボリューム、引数、GPU要求 (`--gpus all` など NVIDIA Container Toolkit 経由) を適用すること。
    * コンテナ起動に成功した場合は、`{{200 OK または 202 Accepted}}` ステータスと成功メッセージ（例: `{"message": "Container 'llama3' starting"}`）を返す。
    * コンテナ起動に失敗した場合は（Dockerエラー、イメージが見つからない等）、`{{500 Internal Server Error}}` とエラー詳細を含むメッセージを返す。
  * **入力:** `{{HTTP POSTリクエスト (パスに service_id)}}`
  * **出力:** `{{HTTPレスポンス (ステータスコード, JSONボディ)}}`

* **FR-04: 手動コンテナ管理API (停止)**
  * 【解説】指定されたサービスのコンテナを手動で停止するAPIに関する要求です。
  * **要求:**
    * `POST /api/v1/service/{service_id}/stop` エンドポイントを実装すること。
    * リクエストパスから `service_id` を抽出し、対応するサービス設定を取得すること。存在しない場合は `{{404 Not Found}}` を返す。
    * 指定されたサービスIDのコンテナが実行中でない場合は、`{{404 Not Found または 成功を示すメッセージ}}` を返す `{{(冪等性考慮)}}`。
    * Docker SDK for Python を使用して、対応するコンテナを停止（および削除 `{{(削除も行うか検討)}}`）すること。
    * コンテナ停止に成功した場合は、`{{200 OK}}` ステータスと成功メッセージ（例: `{"message": "Container 'llama3' stopped"}`）を返す。
    * コンテナ停止に失敗した場合は、`{{500 Internal Server Error}}` とエラー詳細を含むメッセージを返す。
  * **入力:** `{{HTTP POSTリクエスト (パスに service_id)}}`
  * **出力:** `{{HTTPレスポンス (ステータスコード, JSONボディ)}}`

* **FR-05: コンテナ状態取得API (Debug用)**
  * 【解説】指定されたサービスのコンテナの状態を確認するデバッグ用APIに関する要求です。
  * **要求:**
    * `GET /api/v1/container/{service_id}` エンドポイントを実装すること。
    * リクエストパスから `service_id` を抽出し、対応するサービス設定を取得すること。存在しない場合は `{{404 Not Found}}` を返す。
    * Docker SDK for Python を使用して、対応するコンテナの現在の状態（例: `running`, `exited`, `not found`）を取得すること。
    * 取得したコンテナの状態を含むJSONレスポンス（例: `{"service_id": "llama3", "status": "running"}`）を返すこと。
  * **入力:** `{{HTTP GETリクエスト (パスに service_id)}}`
  * **出力:** `{{HTTPレスポンス (ステータスコード 200 OK, JSONボディ)}}`

* **FR-06: 基本的なログ出力**
  * 【解説】サーバーの動作状況を把握するためのログ出力に関する要求です。
  * **要求:**
    * `loguru` ライブラリを使用してログを出力すること。
    * 以下のイベント発生時に、適切なログレベル（INFO, WARNING, ERROR, DEBUG）でログを出力すること:
      * サーバー起動/停止
      * 設定ファイルの読み込み成功/失敗
      * 受信したリクエストの情報（メソッド, パス） `{{(DEBUGレベル推奨)}}`
      * プロキシ転送の開始/完了（転送先含む） `{{(DEBUGレベル推奨)}}`
      * コンテナ管理APIの呼び出しと結果（起動/停止の成功/失敗）
      * Docker操作時のエラー
      * その他、処理中の重要なステップやエラー
    * ログにはタイムスタンプ、ログレベル、メッセージを含めること。
    * ログは標準出力（コンソール）に出力すること `{{(ファイル出力はMVP以降)}}`。
    * `(任意)` `richuru` を使って、コンソール出力を見やすく色付けすることを検討 `{{(MVPに含めるか判断)}}`。
  * **出力:** `{{標準出力へのログメッセージ}}`

---

### 2. 非機能要求の洗い出し (MVPスコープ)

**【解説】**
システムの品質特性に関する要求です。MVP段階では、過度に高い目標は設定せず、基本的な動作を保証するための要求を定義します。

* **NFR-01: パフォーマンス**
  * 【解説】システムの応答時間や処理能力に関する要求です。
  * **要求:**
    * プロキシ機能による追加レイテンシは、通常のネットワーク状況下で `{{平均 100ms 未満}}` を目指す。
    * 手動コンテナ管理API（起動/停止）の応答時間は `{{5秒以内}}` を目指す（Dockerデーモンの応答速度に依存）。
    * 同時に処理できるプロキシリクエスト数について、MVPでは明確な目標値を設定しない `{{(負荷試験はMVP以降)}}`。
* **NFR-02: 信頼性/可用性**
  * 【解説】システムが安定して動作し続ける能力に関する要求です。
  * **要求:**
    * プロキシサーバー自体がクラッシュしないこと（FastAPIの基本的な安定性に依存）。
    * Dockerデーモンとの接続が切断された場合、API呼び出し時にエラーを返し、サーバー自体は動作し続けること `{{(エラーハンドリング)}}`。
    * 特定のサービスコンテナの起動/停止失敗が、他のサービスのプロキシ機能やAPIに影響を与えないこと。
* **NFR-03: 運用性**
  * 【解説】システムの導入、設定、監視のしやすさに関する要求です。
  * **要求:**
    * 設定ファイル (`config.yaml`) の記述方法が直感的であり、READMEに必要な説明が記載されていること `{{(ドキュメント要求)}}`。
    * 基本的な動作状況（リクエスト処理、コンテナ操作）がログから追跡可能であること。
    * PythonとDockerがインストールされた環境で、比較的容易にサーバーを起動できること。
* **NFR-04: 保守性**
  * 【解説】コードの修正や機能追加のしやすさに関する要求です。
  * **要求:**
    * コードは適切な命名規則に従い、理解しやすい構造（モジュール分割など）を意識すること `{{(コーディング規約)}}`。
    * 複雑なロジックにはコメントを追加すること。
    * 主要な機能（Docker操作、設定読み込みなど）は、ある程度モジュール化されていること `{{(設計方針)}}`。
    * `(任意)` コア機能に対する基本的なユニットテストが存在すること `{{(テスト導入時期の再検討)}}`。
* **NFR-05: セキュリティ**
  * 【解説】不正アクセスや情報漏洩を防ぐための要求です。
  * **要求:**
    * MVPでは、ローカル環境での利用を前提とし、外部からの不正アクセスに対する特別な対策は実装しない `{{(スコープ外)}}`。
    * 管理APIへの認証機能は実装しない `{{(スコープ外)}}`。
    * 設定ファイルに機密情報（APIキーなど）を直接記述しない運用を推奨する（ただし仕組みとしては制限しない）。

---

### 3. ユースケースの定義 (MVPスコープ)

**【解説】**
ユーザー（このプロジェクトでは主に開発者自身）が、MVPの機能をどのように利用するかの具体的なシナリオを記述します。これにより、機能がユーザーの目的を達成するためにどのように連携して使われるかを理解し、設計の妥当性を確認します。

* **UC-01: 新しいモデル (llama3) を設定し、手動で起動して利用する**
  * **アクター:** `{{開発者/ユーザー}}`
  * **事前条件:** プロキシサーバーのコードが存在する。Docker、NVIDIA Container Toolkit がインストール済み。`llama-cpp-server` 用のコンテナイメージがビルド済みまたはプル済み。モデルファイルが存在する。
  * **事後条件:** `llama3` サービスがプロキシ経由で利用可能になる。
  * **シナリオ:**
        1. ユーザーは `config.yaml` を編集し、`services` セクションに `llama3` の定義を追加する（`type: llama-cpp-server`, `port`, `image`, `volumes`, `args` などを指定）。
        2. ユーザーはターミナルでプロキシサーバーを起動する (`uvicorn main:app --host 0.0.0.0 --port 11000` など)。
        3. ユーザーは別のターミナルまたはAPIクライアントから `POST /api/v1/service/llama3/start` を実行する。
        4. プロキシサーバーは `llama3` の設定に基づき、Dockerコンテナを起動する。
        5. ユーザーはAPIレスポンス（例: `{"message": "Container 'llama3' starting"}`）を確認する。
        6. ユーザーはコンテナの起動ログや `GET /api/v1/container/llama3` で状態が `running` になることを確認する。
        7. ユーザーはプロキシ経由で推論リクエストを送信する (例: `curl -X POST http://localhost:11000/service/llama3/v1/chat/completions -d '...'`)。
        8. プロキシサーバーはリクエストを `llama3` コンテナに転送し、レスポンスをユーザーに返す。
        9. ユーザーは推論結果を受け取る。

* **UC-02: 利用が終わったモデル (llama3) のコンテナを停止する**
  * **アクター:** `{{開発者/ユーザー}}`
  * **事前条件:** `llama3` サービスのコンテナが実行中である。プロキシサーバーが起動中である。
  * **事後条件:** `llama3` コンテナが停止し、リソースが解放される。プロキシ経由での `llama3` へのアクセスはエラーになる。
  * **シナリオ:**
        1. ユーザーは別のターミナルまたはAPIクライアントから `POST /api/v1/service/llama3/stop` を実行する。
        2. プロキシサーバーは `llama3` コンテナを停止（および削除）する。
        3. ユーザーはAPIレスポンス（例: `{"message": "Container 'llama3' stopped"}`）を確認する。
        4. ユーザーは `docker ps` や `GET /api/v1/container/llama3` でコンテナが存在しない、または `exited` 状態であることを確認する。
        5. ユーザーが再度プロキシ経由で `llama3` にリクエストを送ると、`503 Service Unavailable` (または同等のエラー) が返ってくることを確認する。

* **UC-03: 設定ファイルの間違いに気づく**
  * **アクター:** `{{開発者/ユーザー}}`
  * **事前条件:** プロキシサーバーのコードが存在する。
  * **事後条件:** プロキシサーバーは起動せず、エラーメッセージが表示される。
  * **シナリオ:**
        1. ユーザーは `config.yaml` を編集するが、必須項目（例: `services.myservice.port`）を書き忘れる、またはYAMLのインデントを間違える。
        2. ユーザーはターミナルでプロキシサーバーを起動しようとする。
        3. プロキシサーバーは設定ファイルの読み込みまたはバリデーションに失敗し、エラーメッセージ（例: `ValidationError: 'port' is required for service 'myservice'` や `YAML parsing error at line X`）をコンソールに出力して終了する。
        4. ユーザーはエラーメッセージを見て設定ファイルの間違いに気づき、修正する。

---

このフェーズ1の要求分析に基づき、次のフェーズ2「設計」では、これらの要求を満たすための具体的なソフトウェア構造、APIの詳細、データモデルなどを設計していきます。必要に応じて、GitHub Issueにこれらの要求を分割して登録し、管理していくと良いでしょう。
