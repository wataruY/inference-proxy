## AI推論プロキシサーバー プロジェクト計画骨子

提供された草案に基づき、プロジェクトの計画骨子を作成します。要求分析からMVP開発、リリース、運用までの大まかな流れをカバーします。

### フェーズ0: 計画の準備とスコープ定義 (想定期間: 0.5週)

1. **目標の再確認:**
    * プロジェクトの最終的なゴール（ユーザー課題の解決）を明確にする。
    * 「望ましい状態」が達成すべき主要な価値であることを確認する。
2. **スコープ定義:**
    * **MVP (Minimum Viable Product) の定義:** 最小限の価値を提供できる機能を定義する。
        * 例: 1つのサービス（例: llama.cpp）の手動起動/停止API、基本的なプロキシ機能、基本的なリソース監視（メモリ）、設定ファイルからの読み込み。
    * **MVP以降の機能:** MVPには含めないが将来的に実装したい機能（自動起動/停止、高度なリソース管理、複数サービスタイプ対応テンプレート、SigNoz連携強化など）をリストアップする。
3. **プロジェクト管理ツールの準備:**
    * GitHubリポジトリの作成。
    * GitHub Issueのセットアップ（ラベル、マイルストーンなど）。
    * 開発スタイルで定義されたイテレーションプロセスを念頭に置く。

### フェーズ1: 要求分析 (想定期間: 0.5週)

1. **機能要求の洗い出しと詳細化:**
    * 草案の「望ましい状態」を元に、具体的な機能要求をリストアップする。
        * プロキシ機能（リクエスト転送）
        * コンテナ管理機能（手動起動/停止/再起動）
        * リソース監視機能（基本: メモリ、VRAM）
        * 設定ファイル読み込み機能
        * 基本的なAPIエンドポイント
        * 基本的なログ出力機能
    * MVPスコープに含まれる機能を明確にする。
2. **非機能要求の洗い出し:**
    * パフォーマンス（どの程度のレイテンシを許容するか）
    * 信頼性（コンテナ起動失敗時の挙動など）
    * 運用性（設定の容易さ、監視のしやすさ）
    * 保守性（テストコード、ドキュメントの充実）
3. **ユースケースの定義:**
    * ユーザーがどのようにこのツールを使うか、具体的なシナリオを記述する。
        * 例1: ユーザーが設定ファイルに新しいモデルを追加し、手動APIで起動する。
        * 例2: ユーザーがプロキシ経由で推論リクエストを送信する。
        * 例3: ユーザーがSigNozで基本的なメトリクスを確認する。

### フェーズ2: 設計 (想定期間: 1週)

1. **アーキテクチャ設計:**
    * 主要コンポーネント（FastAPIサーバー、Docker管理モジュール、設定ローダー、リソース監視モジュール、テレメトリモジュール）とその連携方法を図示する。
    * リクエストフロー、コンテナ管理フローを明確にする。
2. **API設計:**
    * 草案のAPIを元に、リクエスト/レスポンス形式（JSON）、ステータスコード、エラーハンドリングを詳細化する。
    * Pydanticモデルを定義し、OpenAPIスキーマを生成する方針を確認する。
3. **データモデル設計:**
    * 設定ファイル（YAML）の詳細なスキーマをPydanticモデルとして定義する。
    * サービスタイプ毎のテンプレート構造を具体化する。
    * 内部で保持する状態（実行中のコンテナ情報、リソース使用状況など）のデータ構造を設計する。
4. **コンテナ管理ロジック設計:**
    * Docker SDK for Pythonを使ったコンテナの起動、停止、状態取得、リソース監視（メモリ、VRAM）の具体的な方法を設計する。
    * NVIDIA Container Toolkitの利用方法を明確にする（`docker run`時の`--gpus`オプションなど）。
    * エラー処理（コンテナ起動失敗、Dockerデーモン接続不可など）を考慮する。
    * *(MVP以降)* 自動起動/停止、リソース解放ロジックのアルゴリズムを設計する。
5. **モニタリング・ロギング設計:**
    * `loguru`と`richuru`によるログ出力形式、ログレベルを定義する。
    * OpenTelemetry SDKの導入箇所、計装する対象（リクエスト、コンテナ操作、リソース監視）を決定する。
    * SigNozに送信する主要なメトリクス、トレース、ログの内容を定義する。
6. **テスト戦略:**
    * ユニットテスト（各モジュール、関数）、結合テスト（APIとコンテナ管理の連携など）の範囲を定義する。
    * `pytest`, `pytest-asyncio`, `pytest-doctest`の具体的な使用方針を決める。
    * Dockerデーモンとのインタラクションをどのようにテストするか（モック、テスト用Docker環境など）を検討する。

### フェーズ3: MVP開発 (想定期間: 3-4週)

1. **開発環境構築:**
    * プロジェクトフォルダ構成の作成。
    * 依存関係管理ツールの設定（例: Poetry, PDM）。
    * Gitリポジトリの初期化とGitHubへのプッシュ。
    * ローカルでのDocker、NVIDIA Container Toolkit、SigNozの実行環境準備。
    * pre-commitフックなどの設定（フォーマッタ、リンタ）。
2. **実装 (Issue駆動開発):**
    * GitHub Issueに基づいてタスクを分割し、PRを作成・レビュー・マージするサイクルで進める。
    * **コア機能実装:**
        * FastAPIアプリケーションの基本構造作成。
        * 設定ファイル（YAML）の読み込みとバリデーション（Pydantic）。
        * 基本的なプロキシロジックの実装。
        * Docker SDKを使ったコンテナの手動起動/停止APIの実装。
        * 基本的なリソース監視の実装。
    * **ロギング実装:** `loguru`, `richuru`によるログ出力設定。
    * **テスト実装:** 実装と並行してユニットテスト、結合テストを作成 (`pytest`)。
    * **OpenTelemetry基本設定:** リクエストトレース、基本的なログ送信。
    * **ドキュメント作成:** README（セットアップ、基本構成、使い方）、設定ファイルの説明。
3. **コードレビュー:**
    * PRごとに実装、テスト、ドキュメントのレビューを実施する。

### フェーズ4: リリース (想定期間: 0.5週)

1. **最終テスト:**
    * MVPスコープの全機能がユースケース通りに動作するかを通しでテストする。
    * 設定ファイルの記述例に基づいたテスト。
    * 基本的なリソース監視がSigNozで確認できるかテストする。
2. **ドキュメント整備:**
    * README、設定例、APIドキュメント（OpenAPI準拠）を最終化する。
3. **リリース準備:**
    * Gitリポジトリにバージョンタグを付与する (例: `v0.1.0`)。
    * GitHub Releasesにリリースノートを作成し、MVPの機能概要、使い方、既知の問題などを記述する。
    * (任意) PyPIへのパッケージ公開準備 or Dockerイメージのビルドと公開 (Docker Hub / GitHub Container Registry)。個人プロジェクトであれば、リポジトリのクローンと手動セットアップで十分な場合もある。
4. **デプロイ:**
    * 開発者自身のローカル環境にリリースバージョンをセットアップし、利用を開始する。

### フェーズ5: 運用とフィードバック (継続)

1. **利用と監視:**
    * 実際にツールを日常的に利用する。
    * SigNozダッシュボードでパフォーマンス、リソース使用状況、エラーログを継続的に監視する。
2. **フィードバック収集とIssue化:**
    * 利用中に発見したバグ、使いにくい点、改善アイデア、追加したい機能などをGitHub Issueとして記録する。
    * 監視データからパフォーマンスボトルネックやリソース管理の問題点を特定し、Issue化する。
3. **次期イテレーション計画:**
    * 作成されたIssueを評価・優先順位付けし、次の開発サイクル（MVP+1）で取り組む内容を決定する。
    * 必要に応じて、要求分析や設計フェーズに戻り、機能追加や変更を行う。
4. **保守:**
    * 重大なバグの修正。
    * 依存ライブラリのアップデート対応。
    * ドキュメントの更新。

### 重要な考慮事項

* **イテレーション:** 各フェーズは厳密にウォーターフォールである必要はなく、特に開発フェーズはアジャイルに進める。「Issue -> PR -> レビュー -> マージ -> リリース -> フィードバック」のサイクルを意識する。
* **テスト:** 開発初期からテストを書くことを徹底する。特にコンテナ操作やリソース管理ロジックは複雑になりがちなので、テストで品質を担保する。
* **ドキュメント:** コードを書くと同時にドキュメントも更新する。README、設定ファイルの説明、APIドキュメントは常に最新の状態を保つ。Pydanticによるスキーマ駆動はドキュメント生成にも役立つ。
* **モニタリング:** 初期からログと基本的なトレースを設定することで、開発中および運用開始後の問題解決が格段に容易になる。

この骨子を元に、各フェーズの具体的なタスクをGitHub Issueに落とし込み、プロジェクトを進めていくことをお勧めします。
